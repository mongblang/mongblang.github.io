---
title: "[프로그래머스] Lv.1 공원 산책 - Python"
date: 2024-12-23 
categories: [코딩테스트 연습, 프로그래머스]
tags: [Python, Algorithm]
layout: post
author: mongblang
---

# 📌&nbsp; **공원 산책**
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/172928)  

# 📝&nbsp; **문제**
---
![문제](/assets/img/codingtest-post-img/PG172928-1.png)
![그림](https://user-images.githubusercontent.com/62426665/217702316-1bd5d3ba-c1d7-4133-bfb5-36bdc85a08ba.png)
![제한사항](/assets/img/codingtest-post-img/PG172928-2.png)

## ✏️&nbsp; **입출력 예시**
---
![예시](/assets/img/codingtest-post-img/PG172928-3.png) 

&nbsp;  

&nbsp;   



## **내 풀이**  
--- 

```python
def solution(park, routes):
    x, y = 0, 0

    direction = {
        "W":[0,-1], 
        "E":[0,1],
        "N":[-1,0],
        "S":[1,0]

    }

    for i in range(len(park)): 
        for j in range(len(park[0])):
            if park[i][j] == 'S':
                x = i
                y = j

    for route in routes:
        way, move_cnt = route.split()
        move_cnt = int(move_cnt) 
        dx, dy = direction[way]

        can_move = True
        next_x = x
        next_y = y

        for _ in range(move_cnt):
            next_x += dx
            next_y += dy

            if next_x < 0 or next_x >= len(park) or next_y < 0 or next_y >= len(park[0]) or park[next_x][next_y] == 'X':
                can_move = False
                break

        if can_move:
            x = next_x
            y = next_y

    return [x,y]
```

#### **코드 해설**  
1. 초기 시작점 x,y를 초기화한다.
2. W,E,N,S에 대한 이동값을 딕셔너리에 저장한다. 
3. 입력으로 받은 지시사항을 반복하는 반복문을 작성한다: 먼저, routes의 방향과 이동 칸 수를 split으로 각 변수에 저장한다.
4. 다음 x와 y의 좌표를 구한다.
5. 갱신하기 전에 이동가능한 곳인지 확인한다. (x나 y값이 음수거나 이동가능한 범위를 초과하거나 장애물이 있다면 반복문 탈출)
6. x, y값을 next_x, next_y로 갱신 후 반환한다. 

&nbsp;  


## **다른 풀이**
---

```python  
class Dog:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.g = {"N": (-1, 0), "W": (0, -1), "E": (0, 1), "S": (1, 0)}

    def move(self, park, direction, distance):
        i, j = self.g[direction]
        x, y = self.x + (i * distance), self.y + (j * distance)
        if x < 0 or y < 0 or x >= len(park) or y >= len(park[0]):
            return park
        elif "X" in park[x][min(self.y, y) : max(self.y, y) + 1] or "X" in [
            row[y] for row in park[min(self.x, x) : max(self.x, x)]
        ]:
            return park
        park[self.x][self.y] = "O"
        park[x][y] = "S"
        self.x = x
        self.y = y
        return park

    @classmethod
    def detect_start_dogs_location(self, park):
        for i, row in enumerate(park):
            for j, item in enumerate(row):
                if item == "S":
                    return i, j


def solution(park, routes):
    park = [list(row) for row in park]
    x, y = Dog.detect_start_dogs_location(park)

    dog = Dog(x, y)

    for route in routes:
        direction, distance = route.split()
        park = dog.move(park, direction, int(distance))

    return [dog.x, dog.y]
```

#### **코드 해설**  
1. `__init__` 메서드로 Dog 클래스를 초기화한다: self.x, self.y로 개의 현재 위치를 저장하고 self.g에 방향별 이동 벡터를 저장한다.
2. `move` 메서드에 이동 로직을 설계한다. i,j 변수에 방향 벡터를 가져온 후 x,y에 최종 목표 위치를 저장한다. 
3. 공원 밖으로 나가는 경우 이동하지 않고, 마찬가지로 장애물이 있다면 (elif~) 역시 이동하지 않는다. 즉, 현재 행, 열에서 출발점과 도착점 사이에 장애물이 있는지 두 경우를 확인한다. 
4. 이전 위치를 "O"로 표시하고 (개가 지나간 자리), 새 위치를 "S"로 표시한 후 위치를 갱신한다. 
5. `detect_start_dogs_location` 메서드에 "S"가 있는 위치를 반환해 사작 위치를 찾는다. 
6. 메인 함수 (solution)에 문자열을 리스트로 변환해 park 변수에 저장한다.
7. x,y에 개의 시작 위치를 저장한 후 Dog 객체를 생성한다 (Dog(x,y)).
8. route의 방향, 이동 칸 수를 각 변수에 저장한 후 move 메서드를 사용해 이동한다.
9. 최종 위치를 반환한다. 


&nbsp;   
&nbsp;  

세상은 넓고 고수는 많다..