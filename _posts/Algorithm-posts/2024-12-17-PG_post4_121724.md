---
title: "[프로그래머스] Lv.1 둘만의 암호- Python"
date: 2024-12-17  
categories: [코딩테스트 연습, 프로그래머스]
tags: [Python, Algorithm]
layout: post
author: mongblang
---

# 📌&nbsp; **둘만의 암호**
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/155652)  

# 📝&nbsp; **문제**
---
![문제](/assets/img/codingtest-post-img/PG155652-1.png)


## ✏️&nbsp; **입출력 예시**
---
![예시](/assets/img/codingtest-post-img/PG155652-2.png)  


&nbsp;  

&nbsp;   



## **내 풀이**  
--- 

```python
def solution(s, skip, index):
    answer = ""
    for i in range(len(s)):
        letter = s[i]
        move_cnt = 0

        while move_cnt < index:
            letter = chr((ord(letter) - ord('a')+1)% 26 + ord('a'))
            if letter not in skip:
                move_cnt += 1
        answer += letter
    return answer
```

#### **코드 해설**  
1. 처음 시작할 단어의 위치를 letter로 지정한다. 
2. 유효한 이동 횟수를 저장할 변수를 정의한 후 해당 이동 횟수가 index보다 작을때까지 while을 사용해 아래 조건들을 반복한다.
3. 아스키코드값을 사용해 z를 넘어가면 다시 a로 돌아오도록 설정한 후 
4. 각 letter가 skip에 없으면 유효 이동 횟수를 1씩 늘려가며 index만큼 이동한다.  
5. answer에 이동한 letter 값을 더해 반환한다. 

&nbsp;  

덧칠하기 문제도 그렇고 왜 이런 문제만 보면 for문으로 푸는 방법이 생각이 나질 않나 모르겠다.   
while문은 코린이가 작성하기에 아직 어렵다 ㅠㅠ 
 
## **다른 풀이**
---

```python  
from string import ascii_lowercase

def solution(s, skip, index):
    result = ''

    a_to_z = set(ascii_lowercase)
    a_to_z -= set(skip)
    a_to_z = sorted(a_to_z)
    l = len(a_to_z)

    dic_alpha = {alpha:idx for idx, alpha in enumerate(a_to_z)}

    for i in s:
        result += a_to_z[(dic_alpha[i] + index) % l]

    return result
```

#### **코드 해설**  
1. a~z까지의 알파벳 리스트에서 skip에 있는 알파벳을 뺀 후 정렬한다.
2. 정렬된 리스트를 순회하며 알파벳:인덱스 구조의 딕셔너리를 생성한다.
3. 딕셔너리를 순회하며 index만큼 이동한 위치의 알파벳을 result에 추가한다. 

&nbsp;   
&nbsp;  

ascii_lowercase라는 함수는 또 처음보네 