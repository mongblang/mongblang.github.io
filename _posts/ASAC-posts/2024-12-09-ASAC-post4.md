---
title: "Python 기초 ③ - 정렬"
date: 2024-12-09
categories: [ASAC]
tags: [데이터분석, python]
layout: post
author: mongblang
---

# **정렬** 
> *기준*에 맞춰 순서를 정리하는 것으로, 기준은 위치, 값의 크기, 알파벳, 문자순 등이 될 수 있다.

- 기준: 위치, 값의 크기, 알파벳, 문자순, 성적순 등등 
- 정렬 가능한 자료형: 리스트,딕셔너리 등 
- 기준을 지정하지 않은 상황에서 동일한 순서가 발생하면 원본의 순서를 그대로 유지하므로 명확하게 정렬의 기준을 제시
- lambda 함수를 사용하면 원하는 기준대로 정렬할 수 있음 

### **활용 예시(코딩테스트, 면접)**
- 코딩테스트: 정렬과 관련된 개별적 알고리즘이 주된 내용은 아니지만 마지막이나 중간에 1~2줄 정도 필요할 때 사용된다. 
    > 원하는 대로 정렬 규칙을 설정 + 필요한 자료형 구성/설정하는 것이 중요!
     - 일반적인 코테에서는 주로 2중 for문까지는 괜찮지만 3중 for 문이 n의3제곱이 된다면 코드를 수정해야 한다. 

 - 대면 면접: 기본적인 정렬 알고리즘 차이점 & 코드로 구현 (파이썬으로 구현 시 10줄 내외)
    - for / index / 규칙: 코드를 작성하는 기본기를 파악하기 용이

---

&nbsp;  

## **1. 파이썬 정렬 기능**   
---  

### **1-1. 값을 기준으로 정렬**  
1. 리스트.sort() 메서드: 값을 기준으로 오름차순(기본) 정렬하며, 리스트 특성상 원본이 바로 변경이 되므로 원본을 유지할 수 없다. 
    ```python
    a = [15, 22, 8, 79, 10]
    a.sort()
    # a = [8, 10, 15, 22, 79]
    ```

2. sorted(원소) 함수: 원소의 값의 크기를 기준으로 정렬, 원본 데이터가 유지되므로 변경된 결과를 사용하려면 따로 할당/연결해야 한다 (사용법은 .sort()와 동일) 

    #### 정렬 기준 
    1. 오름차순 (기본값): `reverse = False` 
        - 문자열일 경우 영어 숫자값이 한글보다 작으므로 영 - 한 순서로 반환
    2. 내림차순: `reverse = True`  
    3. 람다함수 정렬기준: `+ (오름차순) / - (내림차순) 부호` 
        - 조건이 여러개가 있는 경우에 대해 **각 조건별로** 기준을 다 다르게 부여할 때 사용
        - 예: `sorted(jumsu, key = lambda x: -x[1])` = 정렬할 기준 앞에 부호를 붙여 정렬 

    > 파라미터로 사용되므로 위치 기준으로 정렬하는 reverse 메서드와는 기능이 다르며, 정렬기준이 여러개여도 일괄로 정렬하기 때문에 각 기준별로 정렬 시 reverse대신 (+/-)부호를 사용하면 개별 정렬이 가능하다.   

---

### **1-2. 위치를 기준으로 역순 정렬**  
3. reverse() 메서드 / reversed() 함수 : 단순 위치를 기준으로 역순으로 재배치한다.  

&nbsp;  

### **1-3**. lambda를 사용해 특정 기준으로 정렬   
> 원하는 기준대로 정렬하고 싶을 때 lambda 함수를 사용해 표현한다.   
- 형식: `sorted(정렬할 데이터, key = lambda x: 적용할 기준)`  
- 정렬기준: `+ (오름차순) / - (내림차순) 부호` 
    - 예: `sorted(jumsu, key = lambda x: -x[1]`
    - 기준이 여러개일 경우 괄호로 묶어서 적용할 순서대로 나열한다. 
    
    ```python
    # 글자의 길이 순서대로 내림차순 
    str_list = ['좋은하루', 'good morning', '굿모닝', 'niceday']
    a = sorted(str_list, key = lambda x : len(x), reverse=True)

    ```  

&nbsp;  

---

## **2. 정규식**  
> 문자열에 대한 규칙화 문법으로, 문자열 내에서 원하는 패턴을 찾는 규칙을 뜻한다.   
참고: [정규식](https://painted-starfish-9d5.notion.site/1582b2da920780e3a228e91a1592c5fc)

- 일반적인 모든 언어들에 대해 다 존재함 (언어별로 차이가 거의 없음)
- 정규식 패키지: re패키지 - `import re`
- 일반적인 문자열 앞에 r을 붙여 정규식을 작성할 수 있음
    - 예: `r"hello.100$"`

---

&nbsp;  

### 2-1. 기본 종류 
- `*` : 출현 빈도를 나타내는 기호로, 원하는 패턴 0번 이상을 나타낼 수 있다. 
- `[문자들]` : 여러개들 중에서 하나라도 
    예: 주민번호 xxxxxx - [1234]xxxx 또는 [1-4]xxxx
- `.` (온점) : 줄 바꿈을 제외하고 어떠한 형태이던지 공백 또는 문자 1개를 나타냄 
- `패턴{n}` : 패턴의 반복을 지정할 때 사용 
- `\d `: 숫자 0~9와 동일, 편하지만 구체적으로 컨트롤을 할 수 없음

    ### 특정 패턴 검색
    - `re.findall(패턴/찾을 규칙, 어디서 찾을건지)`
        - 예: `re.findall(r"\d+", temp)` = 숫자 1개 이상으로 연결된 것들을 검색 

&nbsp;  

---

&nbsp;  

## **3. 정렬 기본 알고리즘**
> 정렬의 기본 알고리즘은 값을 swap하는 것으로, 쉽게말해 멀티할당이라고 볼 수 있다. 

&nbsp;  

### 3-1. 선택정렬 (O(n²))
> 여러 값 중에 제일 크거나 작은 값 (기준은 상황에 맞게 설정)을 선택/결정하고 제일 큰/작은 값을 빼고 남은 값 중에 다시 제일 큰/작은 값을 선택하는 과정을 반복하는 정렬방법
- 예: 호랑이가 가장 강한 동물이고, 그 다음으로 강한 동물은? 
    1. 가장 큰 값 선택/결정
    2. 가장 큰 값을 제외한 나머지 값 중 가장 큰 값 선택/결정
    3. 위의 과정을 끝까지 반복 

```python
for i_step in range(len(arr)): 
    min_idx = i_step # i번째가 가장 작다고 가정
    for j in range(i_step+1, len(arr)): # i+1위치 ~ 끝까지 위치 비교
        if arr[j] < arr[min_idx]: # 가장 작은 값이 나타나면
            min_idx = j # 찾은 제일 작은 값과 i번째 값을 swap 
    arr[min_idx], arr[i_step] = arr[i_step], arr[min_idx]
```

&nbsp;  

### 3-2. 삽입정렬 (O(n²))
> 기존에 정렬되어있는 상태에서 **중간에** 값들이 추가될 때마다 정렬을 수행하는 방식
- 예: 카드게임할 때 순서대로 카드를 정리 - 기존에 정렬되어있는 상태에서 중간에 값을 삽입 

    #### 선택정렬과의 차이점 
    - 누가 작은지 기록할 필요가 없음
    - 앞으로 갈 수 있을 때 까지 swap, 못 가면 stop (단, 복잡도는 O(n²)로 동일)  

```python
for step in range(1, len(arr)): 
    for i in range(step, 0, -1):
        if arr[i-1] > arr[i]: # 새로 들어온 값이 더 작으면 
            arr[i-1], arr[i] = arr[i], arr[i-1]
```

&nbsp;  

### 3-3. 버블정렬
> 값을 서로 비교하면서 기준에 따라 값을 계속 뒤로 이동시키는 개념의 정렬방식  

- 값을 2개씩 (i, i+1) 비교하면서 뒤로 이동
- 코드상 삽입정렬과 유사하지만 개념상 선택정렬과 유사함 (단, 기록지는 없음)

```python
for step in range(len(arr)):
    for i in range(0, len(arr)-step-1) 
        if arr[i] > arr[i+1]: # 앞에서부터 2개씩 선정하여 비교 
            arr[i], arr[i+1] = arr[i+1], arr[i] # 큰 값을 뒤로 swap 
```

&nbsp;  
